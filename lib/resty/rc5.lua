---
--- Generated by EmmyLua
--- Created by Appla<bhg@live.it>
--- DateTime: 2019/1/11 15:22
---

local ffi = require "ffi"
local ffi_new = ffi.new
local C = ffi.C
local ffi_str = ffi.string
local ffi_copy = ffi.copy
local setmetatable = setmetatable
local type = type
local string_char = string.char
local string_rep = string.rep


local _M = {
    _VERSION = '0.01'
}

local mt = {
    __index = _M
}
--#define  RC5_ENCRYPT   1
--#define  RC5_DECRYPT   0
--#define  RC5_32_INT   unsigned long
--#define  RC5_32_BLOCK   8
--#define  RC5_32_KEY_LENGTH   16 /* This is a default, max is 255 */
--#define  RC5_8_ROUNDS   8
--#define  RC5_12_ROUNDS   12
--#define  RC5_16_ROUNDS   16

local RC5_ENCRYPT = 1
local RC5_DECRYPT = 0
local RC5_32_INT = "unsigned long"
local RC5_32_INT_PTR = ffi_new("unsigned long[1]")

local RC5_32_BLOCK = 8
local RC5_32_KEY_LENGTH = 16 --This is a default, max is 255
local RC5_8_ROUNDS = 8
local RC5_12_ROUNDS = 12
local RC5_16_ROUNDS = 16

-- @see openssl/include/openssl/rc5.h
ffi.cdef [[
    typedef unsigned long RC5_32_INT;

    enum {
        RC5_8_ROUNDS = 8,
        RC5_12_ROUNDS = 12,
        RC5_16_ROUNDS = 16,
    };

    typedef struct rc5_key_st {
        /* Number of rounds */
        int rounds;
        RC5_32_INT data[2 * (RC5_16_ROUNDS + 1)];
    } RC5_32_KEY;

    void RC5_32_set_key(RC5_32_KEY *key, int len, const unsigned char *data,
                        int rounds);
    void RC5_32_ecb_encrypt(const unsigned char *in, unsigned char *out,
                            RC5_32_KEY *key, int enc);
    void RC5_32_encrypt(unsigned long *data, RC5_32_KEY *key);
    void RC5_32_decrypt(unsigned long *data, RC5_32_KEY *key);
    void RC5_32_cbc_encrypt(const unsigned char *in, unsigned char *out,
                            long length, RC5_32_KEY *ks, unsigned char *iv,
                            int enc);
    void RC5_32_cfb64_encrypt(const unsigned char *in, unsigned char *out,
                              long length, RC5_32_KEY *schedule,
                              unsigned char *ivec, int *num, int enc);
    void RC5_32_ofb64_encrypt(const unsigned char *in, unsigned char *out,
                              long length, RC5_32_KEY *schedule,
                              unsigned char *ivec, int *num);
]]
--int EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,
--        const unsigned char *salt, const unsigned char *data, int datal,
--        int count, unsigned char *key,unsigned char *iv);
local rc5_key_ptr_type = ffi.typeof("RC5_32_KEY[1]")

local RC5_32_set_key = C.RC5_32_set_key
local RC5_32_ecb_encrypt = C.RC5_32_ecb_encrypt
local RC5_32_encrypt = C.RC5_32_encrypt
local RC5_32_decrypt = C.RC5_32_decrypt
local RC5_32_cbc_encrypt = C.RC5_32_cbc_encrypt
local RC5_32_cfb64_encrypt = C.RC5_32_cfb64_encrypt
local RC5_32_ofb64_encrypt = C.RC5_32_ofb64_encrypt



---@param str string
---@return boolean
local function is_string(str)
    return type(str) == "string"
end

---非string类型或者空字符串
---@param str string
---@return boolean
local function empty_string(str)
    return type(str) ~= "string" or str == ""
end

--void RC5_32_set_key(RC5_32_KEY *key, int len, const unsigned char *data, int rounds);
---@param key string
---@param rounds number
---@return rc5_key_ptr_type
local function set_key(key, rounds)
    if empty_string(key) then
        return nil, "invalid key, require not empty string!"
    end
    local key_len = #key
    local rc5_key = ffi_new(rc5_key_ptr_type)
    RC5_32_set_key(rc5_key, key_len, key, rounds or RC5_8_ROUNDS)
    return rc5_key
end

--void RC5_32_ecb_encrypt(const unsigned char *in, unsigned char *out, RC5_32_KEY *key, int enc);
local function ecb_encrypt(self, data, enc)
    if empty_string(data) then
        return nil, "invalid data, require not empty string!"
    end
    local data_len = #data
    --填充够8位
    local remainder = data_len % 8
    local padding_len
    if remainder > 0 then
        padding_len = 8 - remainder
        data_len = data_len + padding_len
        data = data .. string_rep(string_char(0), padding_len)
    end

    local buffer = ffi_new("unsigned char[?]", data_len)
    local raw_data = ffi_new("unsigned char[?]", data_len)


    ffi_copy(raw_data, data, data_len)
    for len = 0, data_len , 8 do
        RC5_32_ecb_encrypt(raw_data + len, buffer + len, self._key, enc)
    end
    return ffi_str(buffer, data_len)
end

---@param self table
---@param data string
---@return string
function _M.ecb_encrypt(self, data)
    return ecb_encrypt(self, data, RC5_ENCRYPT)
end

---@param self table
---@param data string
---@return string
function _M.ecb_decrypt(self, data)
    return ecb_encrypt(self, data, RC5_DECRYPT)
end

--void RC5_32_cbc_encrypt(const unsigned char *in, unsigned char *out,
--long length, RC5_32_KEY *ks, unsigned char *iv,
--int enc);
local function cbc_encrypt(self, data, iv, enc)
    if empty_string(data) then
        return nil, "invalid data, require not empty string!"
    end
    iv = iv or self._default_iv
    if empty_string(iv) then
        return nil, "invalid iv, require not empty string!"
    end

    local data_len = #data
    --填充够8位
    local remainder = data_len % 8
    local padding_len
    if remainder > 0 then
        padding_len = 8 - remainder
        data_len = data_len + padding_len
        data = data .. string_rep(string_char(0), padding_len)
    end

    local result = ffi_new("unsigned char[?]", data_len)
    local long_len = ffi_new("long[1]", data_len)

    local iv_len = #iv
    local iv_ptr = ffi_new("unsigned char[?]", iv_len)
    ffi_copy(iv_ptr, iv, iv_len)

    RC5_32_cbc_encrypt(data, result, long_len[0], self._key, iv_ptr, enc)
    return ffi_str(result, long_len[0])
end

---@param self table
---@param data string
---@return string
function _M.cbc_encrypt(self, data, iv)
    return cbc_encrypt(self, data, iv, RC5_ENCRYPT)
end

---@param self table
---@param data string
---@return string
function _M.cbc_decrypt(self, data, iv)
    return cbc_encrypt(self, data, iv, RC5_DECRYPT)
end

-- void RC5_32_cfb64_encrypt(const unsigned char *in, unsigned char *out,
--                              long length, RC5_32_KEY *schedule,
--                              unsigned char *ivec, int *num, int enc);
local function cfb64_encrypt(self, data, iv, enc)
    if empty_string(data) then
        return nil, "invalid data, require not empty string!"
    end
    iv = iv or self._default_iv
    if empty_string(iv) then
        return nil, "invalid iv, require not empty string!"
    end

    local data_len = #data
    local result = ffi_new("unsigned char[?]", data_len)
    local long_len = ffi_new("long[1]", data_len)
    local num = ffi_new("int[1]")
    local iv_len = #iv
    local iv_ptr = ffi_new("unsigned char[?]", iv_len)
    ffi_copy(iv_ptr, iv, iv_len)
    RC5_32_cfb64_encrypt(data, result, long_len[0], self._key, iv_ptr, num, enc)
    return ffi_str(result, long_len[0]), num[0]
end

---@param self table
---@param data string
---@return string
function _M.cfb64_encrypt(self, data, iv)
    return cfb64_encrypt(self, data, iv, RC5_ENCRYPT)
end

---@param self table
---@param data string
---@return string
function _M.cfb64_decrypt(self, data, iv)
    return cfb64_encrypt(self, data, iv, RC5_DECRYPT)
end

--    void RC5_32_ofb64_encrypt(const unsigned char *in, unsigned char *out,
--                              long length, RC5_32_KEY *schedule,
--                              unsigned char *ivec, int *num);
local function ofb64_encrypt(self, data, iv)
    if empty_string(data) then
        return nil, "invalid data, require not empty string!"
    end
    iv = iv or self._default_iv
    if empty_string(iv) then
        return nil, "invalid iv, require not empty string!"
    end

    local data_len = #data
    local result = ffi_new("unsigned char[?]", data_len)
    local long_len = ffi_new("long[1]", data_len)
    local num = ffi_new("int[1]")
    local iv_len = #iv
    local iv_ptr = ffi_new("unsigned char[?]", iv_len)
    ffi_copy(iv_ptr, iv, iv_len)
    RC5_32_ofb64_encrypt(data, result, long_len[0], self._key, iv_ptr, num)
    return ffi_str(result, long_len[0]), num[0]
end

_M.ofb64_encrypt = ofb64_encrypt
_M.ofb64_decrypt = ofb64_encrypt

--新对象
function _M:new(key, rounds, iv)
    local rc5_key, err = set_key(key, rounds)
    if not rc5_key then
        return nil, err
    end

    return setmetatable({
        _key = rc5_key,
        _default_iv = iv
    }, mt)
end

return _M